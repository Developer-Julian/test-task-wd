// <auto-generated />
namespace TestTaskWD.WebApi.Authentication
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Security.Claims;
    using System.Text.Encodings.Web;
    using System.Threading.Tasks;
    using Microsoft.AspNetCore.Authentication;
    using Microsoft.Extensions.Logging;
    using Microsoft.Extensions.Options;
    using Microsoft.Extensions.Primitives;

    internal class ApiKeyAuthenticationHandler :
        AuthenticationHandler<ApiKeyAuthenticationOptions>
    {
        private readonly IClientProfileRepository clientProfileRepository;

        public ApiKeyAuthenticationHandler(
            IOptionsMonitor<ApiKeyAuthenticationOptions> options,
            ILoggerFactory logger,
            UrlEncoder encoder,
            IClientProfileRepository clientProfileRepository,
            ISystemClock clock)
            : base(options, logger, encoder, clock)
        {
            this.clientProfileRepository = clientProfileRepository;
        }

        protected override async Task<AuthenticateResult> HandleAuthenticateAsync()
        {
            ApiKeyAuthenticationHandler authenticationHandler = this;

            StringValues stringValues;
            if (!authenticationHandler.Request.Headers.TryGetValue("Authorization", out stringValues))
            {
                authenticationHandler.Logger.LogTrace("Authorization header is missing");
                return AuthenticateResult.NoResult();
            }

            foreach (string apiKeyHeader in authenticationHandler.ParseApiKeyHeaders((IEnumerable<string>)stringValues))
            {
                ClaimsPrincipal principal = await authenticationHandler.VerifyApiKey(apiKeyHeader);
                if (principal != null)
                {
                    return AuthenticateResult.Success(new AuthenticationTicket(principal, authenticationHandler.Scheme.Name));
                }
            }

            return AuthenticateResult.NoResult();
        }

        private IEnumerable<string> ParseApiKeyHeaders(IEnumerable<string> headerValues) => headerValues.Select<string, string[]>(v => v.Split(
                new char[1]
                {
                    ' ',
                },
                2,
                StringSplitOptions.RemoveEmptyEntries))
            .Where(v => v.Length == 2)
            .Where(v => v[0].Equals("ApiKey", StringComparison.OrdinalIgnoreCase))
            .Select(v => v[1]);

        private async Task<ClaimsPrincipal> VerifyApiKey(string apiKey)
        {
            ApiKeyAuthenticationHandler authenticationHandler = this;
            ClientProfile profile = await authenticationHandler.clientProfileRepository.FindProfile(apiKey);
            if (profile == null)
            {
                authenticationHandler.Logger.LogTrace("No client profile found by ApiKey {apiKey}", apiKey);
                return null;
            }

            authenticationHandler.Logger.LogTrace(
                "Authorized as {clientId} ({displayName}) by ApiKey of {apiKey}",
                profile.ClientId,
                profile.DisplayName,
                MaskHelper.MaskApiKey(apiKey));
            return new ClaimsPrincipal(new ClaimsIdentity(
                authenticationHandler.EnumerateClientProfileClaims(profile),
                authenticationHandler.Scheme.Name));
        }

        private IEnumerable<Claim> EnumerateClientProfileClaims(
            ClientProfile clientProfile)
        {
            ApiKeyAuthenticationHandler authenticationHandler = this;
            yield return new Claim(authenticationHandler.Options.ClientIdClaimType, clientProfile.ClientId);
            if (authenticationHandler.Options.DisplayNameClaimType != null && !string.IsNullOrEmpty(clientProfile.ClientId))
            {
                yield return new Claim(authenticationHandler.Options.DisplayNameClaimType, clientProfile.DisplayName);
            }
        }
    }
}