// <auto-generated />
namespace TestTaskWD.PrivateApi
{
    using System;
    using System.Diagnostics;
    using System.Threading.Tasks;
    using Serilog;
    using Serilog.Context;

    internal abstract class ApiServiceBase<TClientFactory>
    {
        private const string LogMessageParameters = "RequestParameters";

        private const string LogMessageTemplate = "Call {ProxyMethod} completed in {ProxyElapsed} ms with '{ProxyStatus}' result";

        private readonly TClientFactory clientFactory;

        protected ApiServiceBase(TClientFactory clientFactory)
        {
            this.clientFactory = clientFactory;
        }

        protected delegate bool HandleException(Exception exception);

        protected delegate bool HandleException<TResult>(Exception exception, out TResult result);

        protected abstract ILogger Logger { get; }

        protected async Task ExecuteAsync<TClient>(
            string logMethodName,
            object logParameters,
            Func<TClientFactory, Task<TClient>> createClient,
            Func<TClient, Task> executeClient,
            HandleException handleException = null)
        {
            var client = await createClient(this.clientFactory);
            var stopwatch = Stopwatch.StartNew();

            using (LogContext.PushProperty(LogMessageParameters, logParameters))
            {
                try
                {
                    await executeClient(client);
                    TraceProxySuccess<TClient>(logMethodName, stopwatch.ElapsedMilliseconds);
                }
                catch (Exception ex)
                {
                    var elapsed = stopwatch.ElapsedMilliseconds;
                    if (handleException != null && handleException(ex))
                    {
                        TraceProxySuccess<TClient>(logMethodName, elapsed);
                        return;
                    }

                    TraceProxyError<TClient>(logMethodName, elapsed);
                    this.LogExecuteException(ex);
                    throw;
                }
            }
        }

        protected async Task<TResult> ExecuteAsync<TClient, TResult>(
            string logMethodName,
            object logParameters,
            Func<TClientFactory, Task<TClient>> createClient,
            Func<TClient, Task<TResult>> executeClient,
            HandleException<TResult> handleException = null)
        {
            var client = await createClient(this.clientFactory);
            var stopwatch = Stopwatch.StartNew();

            using (LogContext.PushProperty(LogMessageParameters, logParameters))
            {
                try
                {
                    var result = await executeClient(client);
                    TraceProxySuccess<TClient>(logMethodName, stopwatch.ElapsedMilliseconds);
                    return result;
                }
                catch (Exception ex)
                {
                    var elapsed = stopwatch.ElapsedMilliseconds;
                    if (handleException != null && handleException(ex, out var result))
                    {
                        TraceProxySuccess<TClient>(logMethodName, elapsed);
                        return result;
                    }

                    TraceProxyError<TClient>(logMethodName, elapsed);
                    this.LogExecuteException(ex);
                    throw;
                }
            }
        }

        private static void TraceProxySuccess<TClient>(string method, long elapsed) => Log.ForContext<TClient>()
            .Information(LogMessageTemplate, method, elapsed, "success");

        private static void TraceProxyError<TClient>(string method, long elapsed) => Log.ForContext<TClient>()
            .Information(LogMessageTemplate, method, elapsed, "error");

        private void LogExecuteException(Exception ex)
            => this.Logger.Error(ex, "An unhandled error has occurred while executing request");
    }
}
