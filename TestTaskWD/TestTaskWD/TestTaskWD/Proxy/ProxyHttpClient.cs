// <auto-generated />
namespace TestTaskWD.Proxy
{
    using System;
    using System.Net.Http;
    using System.Threading.Tasks;
    using TestTaskWD.Proxy.Exceptions;

    internal sealed class ProxyHttpClient : IProxyHttpClient
    {
        private readonly IHttpClientFactory httpClientFactory;

        public ProxyHttpClient(IHttpClientFactory httpClientFactory)
        {
            this.httpClientFactory = httpClientFactory;
        }

        public async Task<byte[]> ApplyAsync(ProxyRequestDefinition definition)
        {
            var request = new HttpRequestMessage
            {
                RequestUri = new Uri(definition.Url),
                Method = new HttpMethod(definition.Method),
            };

            foreach (var (key, value) in definition.Headers)
            {
                request.Headers.TryAddWithoutValidation(key, value);
            }

            if (definition.Body != null)
            {
                request.Content = new ByteArrayContent(definition.Body);
                foreach (var (key, value) in definition.Headers)
                {
                    request.Content.Headers.TryAddWithoutValidation(key, value);
                }
            }

            var client = this.httpClientFactory.CreateClient();
            var response = await client.SendAsync(request);

            var result = await response.Content.ReadAsByteArrayAsync();
            if (response.IsSuccessStatusCode)
            {
                return result;
            }

            var responseString = await response.Content.ReadAsStringAsync();
            throw new RequestException(
                response.StatusCode,
                response.ReasonPhrase,
                responseString);
        }
    }
}
