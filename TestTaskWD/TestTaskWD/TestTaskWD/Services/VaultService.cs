// <auto-generated />
namespace TestTaskWD.Services
{
    using Serilog;
    using System;
    using System.Collections.Generic;
    using System.Text;
    using System.Threading.Tasks;
    using TestTaskWD.Configuration.Vault;

    public class VaultService : IVaultService
    {
        private const string ApiKeySecretPropertyName = "apiKey";

        private readonly VaultConfiguration vaultConfiguration;

        private readonly ILogger logger;

        public VaultService(
            VaultConfiguration vaultConfiguration)
        {
            this.vaultConfiguration = vaultConfiguration;
            this.logger = Log.ForContext<VaultService>();
        }

        public async Task<string> FindApiKeyAsync(string apiKeyPath)
        {
            var secretPath = this.GetVaultSecretFullPath(apiKeyPath);
            return await this.FindSecretValueInternalAsync(secretPath, ApiKeySecretPropertyName);
        }

        private string GetVaultSecretFullPath(string apiKeyPath)
        {
            var apiKeyPrefix = this.vaultConfiguration.Client.CredentialsSecretPrefix;
            if (string.IsNullOrWhiteSpace(apiKeyPrefix))
            {
                return apiKeyPath;
            }

            return new StringBuilder()
                .Append(apiKeyPrefix.TrimEnd('/'))
                .Append('/')
                .Append(apiKeyPath)
                .ToString();
        }

        private async Task<string> FindSecretValueInternalAsync(string secretPath, string secretPropertyName)
        {
            IReadOnlyDictionary<string, string> secret;

            try
            {
                // TODO: realization of get vault secret
                secret = new Dictionary<string, string>()
                    { { secretPropertyName, this.vaultConfiguration.Authentication.Token } };
            }
            catch (Exception ex)
            {
                this.logger.Error(ex, "Vault secret '{SecretPath}' read failed", secretPath);
                throw;
            }

            if (secret.ContainsKey(secretPropertyName))
            {
                return secret[secretPropertyName];
            }

            this.logger.Warning(
                "Secret '{SecretPath}' property '{SecretPropertyName}' not found",
                secretPath,
                secretPropertyName);
            return await Task.FromResult(string.Empty);
        }
    }
}